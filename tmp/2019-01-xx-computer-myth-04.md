ALU(Arithmetic Logic Unit)는 컴퓨터에서 모든 연산을 담당하는 아주 중요한 칩이다. 우리가 만들어갈 컴퓨터는 16bit 체계이므로, ALU 칩은 16bit 단위로 명령어들을 받게 될 것이다.

따라서 우선은 이전에 본 NAND, AND 게이트들도 16bit 단위로 동작하도록 만들어야 한다. 이른바 NAND16, AND16 게이트다. 이들의 구현은 간단하게도 게이트 16개를 나란히 두면 된다.

\<diagrams\>

수학적 연산을 수행하기 위한 게이트도 필요한데, Adder16라고 부르자. 이 게이트는 아래와 같이 두 개의 16bit의 덧셈을 수행한다.

\<diagram\>

우리가 가진 재료들로 어떻게 Adder16 게이트를 만들 수 있을까? Half-adder, Full-adder, Adder16을 순차적으로 만들어갈 수 있다. Half-adder는 2개의 bit를 받아서 carry와 sum이라는 두 개의 출력을 내는 게이트이다. Full-adder는 3개의 bit를 받아서 carry와 sum, 두 개의 출력을 낸다. 즉 a와 b라는 두 개의 bit와 이전 연산에서 나온 carry값, 총 3개의 bit를 더하는 역할을 한다. 이 둘을 조합하여 Add16을 만들 수 있다.

\<diagrams\>

ALU는 x와 y라는 16bit 입력을 받고 16bit의 출력을 내놓는 f(x, y) = out 의 역할을 하는 게이트이다. 얼마나 다양한 연산(f)을 할 수 있는지는 컴퓨터 아키텍처의 디자인에 따라 다르다. 우리가 살펴볼 아키텍처에서는 control bit라고 불리는 6개의 bit를 이용해서 어떤 연산을 수행할 것인지 정의할 것이다. 이 각각의 bit는 아주 단순한 연산을 할 것인지 말 것인지를 가리킨다. 예컨대, 6개의 control bit 중 첫 번째를 'zx'라고 부를 때, zx=1일때는 x input을 0으로 만들고 zx=0일때는 그대로 둔다 라는 연산으로 정의한다. 이 연산은 우리가 이미 가지고있는 logic gate로 충분히 구현할 수 있다. 이런 단순한 연산들을 조합해서 더 고차원적인 연산을 설계할 수 있다. 6개의 control bit를 사용하므로 총 2<sup>6</sup>개, 즉 64개의 연산들을 우리 ALU 칩은 수행할 수 있게 된다. 아래는 ALU칩의 정의와 수행할 수 있는 64개의 연산 중 일부만 나타낸 표이다.

\<diagram\>

예컨대, 위 표에서 ALU가 어떻게 x - 1이라는 연산을 수행하는지 보자. x는 그대로 둔다. zy=1이므로 y를 0으로 만들고, ny=1이므로 이 값을 모두 반전시킨다. 그러므로 y는 1111 1111 1111 1111이 된다. 마지막으로 f가 1이기 때문에 x + y를 수행하는데, 2's complement에 의해 y의 값은 -1이다. 따라서, x - 1이라는 연산이 된다.

위 테이블을 보면 현재 우리의 ALU는 x * y라는 곱셈을 수행할 수 없다. control bit를 6개만 사용하는 아키텍처이기에 표현할 수 있는 연산에도 한계가 있다. 당연히, 사용할 수 있는 control bit의 갯수가 많을수록 ALU는 더 다양한 연산을 할 수 있게 된다. 이 컴퓨터에서는 곱셈이 ALU에서 구현되어 있지는 않지만, 소프트웨어 레벨(정확하게는 운영체제)에서 구현하게 된다. 속도 측면에서는 당연히 모든 연산을 ALU에서 할 수 있는 것이 빠르다. 하지만 ALU에 기능이 추가될수록 비용이 올라간다. 이 trade-off에서
우리는 값싼 ALU를 만드는 대신, 필요한 다른 연산들은 소프트웨어에서 구현한다.
