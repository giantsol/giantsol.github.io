---
title: "The Computer Myth - ALU (Part 04)"
tags:
  - cs fundamental
---

컴퓨터라는 기계는 2개의 큰 부품의 상호작용이다. 첫째, 명령어에 따라 연산을 하는 연산 장치. 둘째, 현재의 상태를 기억하는 기억 장치. CPU(Central Processing Unit)이라는 칩이 연산 장치를 맡고, 메모리, 또는 RAM(Random Access Memory)이라는 칩이 기억 장치 역할을 한다. 이 글에서 살펴볼 ALU(Arithmetic Logic Unit)라는 칩은 CPU에 포함된 칩으로써, 실질적으로 컴퓨터의 모든 수학적, 논리적 연산 수행을 담당한다. 즉, 우리가 살펴볼 컴퓨터는 16bit 아키텍처이므로, ALU는 모든 16bit 길이의 명령어들에 대한 연산을 수행한다.

다양한 연산을 구현하기 위해 지금까지 봐왔던 NAND, AND, OR 게이트들이 사용된다. 우리는 지금까지 이 게이트들을 1bit 단위로만 사용했는데, 아주 간단하게 16bit 단위로 동작하도록 확장시킬 수 있다. 예컨대, 아래와 같은 AND16 게이트를 만들려면 AND 게이트를 16개 나란히 두면 된다!

\<diagrams\>

수학적 연산을 수행하기 위한 게이트도 필요한데, Adder16라고 부르자. 이 게이트는 아래와 같이 두 개의 16bit의 덧셈을 수행한다.

\<diagram\>

우리가 가진 재료들로 어떻게 Adder16 게이트를 만들 수 있을까? Half-adder, Full-adder, Adder16을 순차적으로 만들어갈 수 있다. Half-adder는 2개의 bit를 받아서 carry와 sum이라는 두 개의 출력을 내는 게이트이다. Full-adder는 3개의 bit를 받아서 carry와 sum, 두 개의 출력을 낸다. 즉 a와 b라는 두 개의 bit와 이전 연산에서 나온 carry값, 총 3개의 bit를 더하는 역할을 한다. 이 둘을 조합하여 Add16을 만들 수 있다.

\<diagrams\>

ALU는 x와 y라는 16bit 입력을 받고 16bit의 출력을 내놓는 f(x, y) = out 의 역할을 하는 게이트이다. 얼마나 다양한 연산(f)을 할 수 있는지는 컴퓨터 아키텍처의 디자인에 따라 다르다. 우리가 살펴볼 아키텍처에서는 control bit라고 불리는 6개의 bit를 이용해서 어떤 연산을 수행할 것인지 정의할 것이다. 이 각각의 bit는 아주 단순한 연산을 할 것인지 말 것인지를 가리킨다. 예컨대, 6개의 control bit 중 첫 번째를 'zx'라고 부를 때, zx=1일때는 x input을 0으로 만들고 zx=0일때는 그대로 둔다 라는 연산으로 정의한다. 이 연산은 우리가 이미 가지고있는 logic gate로 충분히 구현할 수 있다. 이런 단순한 연산들을 조합해서 더 고차원적인 연산을 설계할 수 있다. 6개의 control bit를 사용하므로 총 2<sup>6</sup>개, 즉 64개의 연산들을 우리 ALU 칩은 수행할 수 있게 된다. 아래는 ALU칩의 정의와 수행할 수 있는 64개의 연산 중 일부만 나타낸 표이다.

\<diagram\>

예컨대, 위 표에서 ALU가 어떻게 x - 1이라는 연산을 수행하는지 보자. x는 그대로 둔다. zy=1이므로 y를 0으로 만들고, ny=1이므로 이 값을 모두 반전시킨다. 그러므로 y는 1111 1111 1111 1111이 된다. 마지막으로 f가 1이기 때문에 x + y를 수행하는데, 2's complement에 의해 y의 값은 -1이다. 따라서, x - 1이라는 연산이 된다.

위 테이블을 보면 현재 우리의 ALU는 x * y라는 곱셈을 수행할 수 없다. control bit를 6개만 사용하는 아키텍처이기에 표현할 수 있는 연산에도 한계가 있다. 당연히, 사용할 수 있는 control bit의 갯수가 많을수록 ALU는 더 다양한 연산을 할 수 있게 된다. 이 컴퓨터에서는 곱셈이 ALU에서 구현되어 있지는 않지만, 소프트웨어 레벨(정확하게는 운영체제)에서 구현하게 된다. 속도 측면에서는 당연히 모든 연산을 ALU에서 할 수 있는 것이 빠르다. 하지만 ALU에 기능이 추가될수록 비용이 올라간다. 이 trade-off에서
우리는 값싼 ALU를 만드는 대신, 필요한 다른 연산들은 소프트웨어에서 구현한다.
